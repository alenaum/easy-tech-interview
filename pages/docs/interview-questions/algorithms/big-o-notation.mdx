# Big O notation

## Description
Big O notation is a way to describe time complexity of an algorithm. It shows the worst case scenario.
It shows only dependency of time over amount of elements. (e.g., we do not care about the base of the logarithm - it is just O(log n))

## Possible values
There are a few accepted values (from best to worst):

| Complexity  | Function   | Description                                                                                                       |
| :---------- | :--------- | :---------------------------------------------------------------------------------------------------------------- |
| Linear      | O(1)       | No iteration, no recursion; an atomic action is done                                                              |
| Logarithmic | O(log n)   | Something is split in halves (binary search), recursion (but it depends)                                          |
| Linear      | O(n)       | Every element of the collection is touched                                                                        |
| Loglinear   | O(n log n) | O(log n) operation will happen n times: recursive sorting; binary tree sorting; most effective sorting algorithms |
| Polynomial  | O(n^x)     | n^2/n^3 nested loops                                                                                              |
| Exponential | O(x^n)     | O(2^n), towers of Hanoi, Fibonacci sequence, try every possible combination                                       |
| Factorial   | O(n!)      | brute force solution of salesman problem                                                                          |

## Big O rules
1. Different steps are added
	O(a+b), where a and b are constants for particular actions
2. Skip constants
	O(n) can stand for running through for-loop twice. We want to see the function, not precise values
3. Different inputs = different variables
	O(mn) stands for a function running for-loop for m array n times
4. Drop non-dominant terms
	O(n+n^2) => O(n^2) - take heavier function into consideration


## Known Complexities
| Algorithm                        | Complexity                             |
| :------------------------------- | :------------------------------------- |
| Get value from dictionary by Key | O(1)                                   |
| Get value from array by index    | O(1)                                   |
| Linear Search                    | O(n)                                   |
| Binary Search                    | O(log n)                               |
| Add item to a heap               | O(log n)                               |
| for-loop                         | O(n)                                   |
| Heap Sort                        | O(n log n)                             |
| Merge Sort                       | O(n log n)                             |
| Quick Sort                       | O(n log n) - average / O(n^2) - worst  |
| Bubble Sort                      | O(n^2)                                 |
| Insertion Sort                   | O(n^2)                                 |
| Selection Sort                   | O(n^2)                                 |
| Bucket Sort                      | O(n^2)                                 |

## References
https://builtin.com/software-engineering-perspectives/nlogn
https://www.bigocheatsheet.com/
https://www.youtube.com/watch?v=v4cd1O4zkGw&ab_channel=HackerRank